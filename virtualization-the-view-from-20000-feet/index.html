<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta charset="utf-8">
  
  <link rel="stylesheet" href="../vendor/katex/katex.min.css">
<script defer type="text/javascript" src="../vendor/katex/katex.min.js"></script>
<script defer type="text/javascript" src="../vendor/katex/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script>
  
  <link rel="stylesheet" type="text/css" href="../css/syntax.css">
  <link rel="stylesheet" type="text/css" href="../css/tufte.css">
  <link rel="stylesheet" type="text/css" href="../css/custom.css">
  
  <title>Virtualization The View from 20,000 Feet - talks</title>
  
</head>
<body>
        <nav class="group">
          <a href="../">home</a>
          <a href="https://github.com/contrun/talks/">github</a>
      </nav>

  <article>
    <section>
      <div class="post_title">
  <h2 class="post_title"><a href=".././virtualization-the-view-from-20000-feet/">Virtualization The View from 20,000 Feet</a></h2>
</div>

<div class="info">
    Posted on March  1, 2022
    
</div>


<div class="toc"><div class="header">Table of Contents</div>
<ul>
<li><a href="#the-crux-how-to-virtualize-the-machine-underneath-the-os">THE CRUX: HOW TO VIRTUALIZE THE MACHINE UNDERNEATH THE OS?</a></li>
<li><a href="#popek-and-goldberg-virtualization-requirements">Popek and Goldberg virtualization requirements</a>
<ul>
<li><a href="#sensentive-instructions">Sensentive Instructions</a>
<ul>
<li><a href="#control-sensitive">Control-sensitive</a></li>
<li><a href="#behavior-senstive">Behavior-senstive</a></li>
</ul></li>
<li><a href="#popek-and-goldberg-first-theorem">Popek and Goldberg First theorem</a></li>
<li><a href="#trap-and-emulate">Trap and Emulate</a></li>
</ul></li>
<li><a href="#vt-x">VT-x</a>
<ul>
<li><a href="#virtual-machine-extensions">Virtual Machine Extensions</a></li>
<li><a href="#life-cycle-of-vmm-software">Life Cycle of VMM Software</a></li>
<li><a href="#vmcs">VMCS</a>
<ul>
<li><a href="#whats-it">What’s it?</a></li>
<li><a href="#whats-in-it">What’s in it?</a></li>
</ul></li>
</ul></li>
<li><a href="#kvm">KVM</a>
<ul>
<li><a href="#write-your-own-hypervisor">Write your own hypervisor</a></li>
</ul></li>
<li><a href="#qemu">Qemu</a></li>
<li><a href="#next-step">Next step</a>
<ul>
<li><a href="#other-virtualization-techniques">other virtualization techniques</a></li>
<li><a href="#memory-virtualization">memory virtualization</a></li>
<li><a href="#interupt-virtualiazation">interupt virtualiazation</a></li>
<li><a href="#more-platforms">more platforms</a></li>
<li><a href="#virtualization-on-platforms-whose-isa-does-not-support-virtualisation">virtualization on platforms whose ISA does not support virtualisation</a></li>
<li><a href="#performance">performance</a></li>
<li><a href="#static-partition-virtualization">static partition virtualization</a></li>
<li><a href="#os-level-virtualization">OS-level virtualization</a></li>
<li><a href="#para-virtualization">para-virtualization</a></li>
<li><a href="#emulation">emulation</a></li>
</ul></li>
</ul>
</div>
<h1 id="the-crux-how-to-virtualize-the-machine-underneath-the-os">THE CRUX: HOW TO VIRTUALIZE THE MACHINE UNDERNEATH THE OS?</h1>
<p>The virtual machine monitor must transparently virtualize the machine underneath the OS; what are the techniques required to do so?</p>
<h1 id="popek-and-goldberg-virtualization-requirements">Popek and Goldberg virtualization requirements</h1>
<h2 id="sensentive-instructions">Sensentive Instructions</h2>
<h3 id="control-sensitive">Control-sensitive</h3>
<p>Update system state, e.g. change GDTR, direct access to PM, VMXON.</p>
<h3 id="behavior-senstive">Behavior-senstive</h3>
<p>Semeantics depends on the system state, e.g. visibility to IDT.</p>
<h2 id="popek-and-goldberg-first-theorem">Popek and Goldberg First theorem</h2>
<p>For any conventional third-generation computer, a virtual machine monitor may be constructed if the set of sensitive instructions for that computer is a subset of the set of privileged instructions.</p>
<h2 id="trap-and-emulate">Trap and Emulate</h2>
<p><img src="../pictures/syscall-with-and-without-vmm.png" /></p>
<p>source: <a href="https://pages.cs.wisc.edu/~remzi/OSTEP/vmm-intro.pdf">Operating Systems: Three Easy Pieces</a></p>
<h1 id="vt-x">VT-x</h1>
<h2 id="virtual-machine-extensions">Virtual Machine Extensions</h2>
<ul>
<li>Root/Non-root modes</li>
<li>VM instructions</li>
</ul>
<h2 id="life-cycle-of-vmm-software">Life Cycle of VMM Software</h2>
<p><img src="../pictures/vmm-guests-life-cycle.png" /></p>
<p>source: <a href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">Intel® 64 and IA-32 Architectures Software Developer Manuals</a></p>
<h2 id="vmcs">VMCS</h2>
<h3 id="whats-it">What’s it?</h3>
<p>A data structuwre which control the behavior of processor in VMX non-root mode and control VMX transitions. <img src="../pictures/interaction-of-hypervisor-and-guests.png" /></p>
<p>source: <a href="https://doi.org/10.2200/S00754ED1V01Y201701CAC038">Hardware and Software Support for Virtualization</a></p>
<h3 id="whats-in-it">What’s in it?</h3>
<p><a href="https://github.com/LordNoteworthy/cpu-internals/blob/master/VMCS-Layout.pdf">VMCS-Layout.pdf</a></p>
<h1 id="kvm">KVM</h1>
<h2 id="write-your-own-hypervisor">Write your own hypervisor</h2>
<p>source: <a href="https://lwn.net/Articles/658511/">Using the KVM API​</a></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1"></a><span class="co">/* Sample code for /dev/kvm API</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="co"> *</span></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="co"> * Copyright (c) 2015 Intel Corporation</span></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="co"> * Author: Josh Triplett &lt;josh@joshtriplett.org&gt;</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="co"> *</span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="co"> * Permission is hereby granted, free of charge, to any person obtaining a copy</span></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="co"> * of this software and associated documentation files (the &quot;Software&quot;), to</span></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="co"> * deal in the Software without restriction, including without limitation the</span></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="co"> * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or</span></span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="co"> * sell copies of the Software, and to permit persons to whom the Software is</span></span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="co"> * furnished to do so, subject to the following conditions:</span></span>
<span id="cb1-12"><a href="#cb1-12"></a><span class="co"> *</span></span>
<span id="cb1-13"><a href="#cb1-13"></a><span class="co"> * The above copyright notice and this permission notice shall be included in</span></span>
<span id="cb1-14"><a href="#cb1-14"></a><span class="co"> * all copies or substantial portions of the Software.</span></span>
<span id="cb1-15"><a href="#cb1-15"></a><span class="co"> *</span></span>
<span id="cb1-16"><a href="#cb1-16"></a><span class="co"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span></span>
<span id="cb1-17"><a href="#cb1-17"></a><span class="co"> * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span></span>
<span id="cb1-18"><a href="#cb1-18"></a><span class="co"> * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span></span>
<span id="cb1-19"><a href="#cb1-19"></a><span class="co"> * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span></span>
<span id="cb1-20"><a href="#cb1-20"></a><span class="co"> * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING</span></span>
<span id="cb1-21"><a href="#cb1-21"></a><span class="co"> * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS</span></span>
<span id="cb1-22"><a href="#cb1-22"></a><span class="co"> * IN THE SOFTWARE.</span></span>
<span id="cb1-23"><a href="#cb1-23"></a><span class="co"> */</span></span>
<span id="cb1-24"><a href="#cb1-24"></a><span class="pp">#include </span><span class="im">&lt;err.h&gt;</span></span>
<span id="cb1-25"><a href="#cb1-25"></a><span class="pp">#include </span><span class="im">&lt;fcntl.h&gt;</span></span>
<span id="cb1-26"><a href="#cb1-26"></a><span class="pp">#include </span><span class="im">&lt;linux/kvm.h&gt;</span></span>
<span id="cb1-27"><a href="#cb1-27"></a><span class="pp">#include </span><span class="im">&lt;stdint.h&gt;</span></span>
<span id="cb1-28"><a href="#cb1-28"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb1-29"><a href="#cb1-29"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb1-30"><a href="#cb1-30"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb1-31"><a href="#cb1-31"></a><span class="pp">#include </span><span class="im">&lt;sys/ioctl.h&gt;</span></span>
<span id="cb1-32"><a href="#cb1-32"></a><span class="pp">#include </span><span class="im">&lt;sys/mman.h&gt;</span></span>
<span id="cb1-33"><a href="#cb1-33"></a><span class="pp">#include </span><span class="im">&lt;sys/stat.h&gt;</span></span>
<span id="cb1-34"><a href="#cb1-34"></a><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></span>
<span id="cb1-35"><a href="#cb1-35"></a></span>
<span id="cb1-36"><a href="#cb1-36"></a><span class="dt">int</span> main(<span class="dt">void</span>) {</span>
<span id="cb1-37"><a href="#cb1-37"></a>  <span class="dt">int</span> kvm, vmfd, vcpufd, ret;</span>
<span id="cb1-38"><a href="#cb1-38"></a>  <span class="dt">const</span> <span class="dt">uint8_t</span> code[] = {</span>
<span id="cb1-39"><a href="#cb1-39"></a>      <span class="bn">0xba</span>, <span class="bn">0xf8</span>, <span class="bn">0x03</span>, <span class="co">/* mov $0x3f8, %dx */</span></span>
<span id="cb1-40"><a href="#cb1-40"></a>      <span class="bn">0x00</span>, <span class="bn">0xd8</span>,       <span class="co">/* add %bl, %al */</span></span>
<span id="cb1-41"><a href="#cb1-41"></a>      <span class="bn">0x04</span>, <span class="ch">'0'</span>,        <span class="co">/* add $'0', %al */</span></span>
<span id="cb1-42"><a href="#cb1-42"></a>      <span class="bn">0xee</span>,             <span class="co">/* out %al, (%dx) */</span></span>
<span id="cb1-43"><a href="#cb1-43"></a>      <span class="bn">0xb0</span>, <span class="ch">'\n'</span>,       <span class="co">/* mov $'\n', %al */</span></span>
<span id="cb1-44"><a href="#cb1-44"></a>      <span class="bn">0xee</span>,             <span class="co">/* out %al, (%dx) */</span></span>
<span id="cb1-45"><a href="#cb1-45"></a>      <span class="bn">0xf4</span>,             <span class="co">/* hlt */</span></span>
<span id="cb1-46"><a href="#cb1-46"></a>  };</span>
<span id="cb1-47"><a href="#cb1-47"></a>  <span class="dt">uint8_t</span> *mem;</span>
<span id="cb1-48"><a href="#cb1-48"></a>  <span class="kw">struct</span> kvm_sregs sregs;</span>
<span id="cb1-49"><a href="#cb1-49"></a>  <span class="dt">size_t</span> mmap_size;</span>
<span id="cb1-50"><a href="#cb1-50"></a>  <span class="kw">struct</span> kvm_run *run;</span>
<span id="cb1-51"><a href="#cb1-51"></a></span>
<span id="cb1-52"><a href="#cb1-52"></a>  kvm = open(<span class="st">&quot;/dev/kvm&quot;</span>, O_RDWR | O_CLOEXEC);</span>
<span id="cb1-53"><a href="#cb1-53"></a>  <span class="cf">if</span> (kvm == -<span class="dv">1</span>)</span>
<span id="cb1-54"><a href="#cb1-54"></a>    err(<span class="dv">1</span>, <span class="st">&quot;/dev/kvm&quot;</span>);</span>
<span id="cb1-55"><a href="#cb1-55"></a></span>
<span id="cb1-56"><a href="#cb1-56"></a>  <span class="co">/* Make sure we have the stable version of the API */</span></span>
<span id="cb1-57"><a href="#cb1-57"></a>  ret = ioctl(kvm, KVM_GET_API_VERSION, NULL);</span>
<span id="cb1-58"><a href="#cb1-58"></a>  <span class="cf">if</span> (ret == -<span class="dv">1</span>)</span>
<span id="cb1-59"><a href="#cb1-59"></a>    err(<span class="dv">1</span>, <span class="st">&quot;KVM_GET_API_VERSION&quot;</span>);</span>
<span id="cb1-60"><a href="#cb1-60"></a>  <span class="cf">if</span> (ret != <span class="dv">12</span>)</span>
<span id="cb1-61"><a href="#cb1-61"></a>    errx(<span class="dv">1</span>, <span class="st">&quot;KVM_GET_API_VERSION %d, expected 12&quot;</span>, ret);</span>
<span id="cb1-62"><a href="#cb1-62"></a></span>
<span id="cb1-63"><a href="#cb1-63"></a>  vmfd = ioctl(kvm, KVM_CREATE_VM, (<span class="dt">unsigned</span> <span class="dt">long</span>)<span class="dv">0</span>);</span>
<span id="cb1-64"><a href="#cb1-64"></a>  <span class="cf">if</span> (vmfd == -<span class="dv">1</span>)</span>
<span id="cb1-65"><a href="#cb1-65"></a>    err(<span class="dv">1</span>, <span class="st">&quot;KVM_CREATE_VM&quot;</span>);</span>
<span id="cb1-66"><a href="#cb1-66"></a></span>
<span id="cb1-67"><a href="#cb1-67"></a>  <span class="co">/* Allocate one aligned page of guest memory to hold the code. */</span></span>
<span id="cb1-68"><a href="#cb1-68"></a>  mem = mmap(NULL, <span class="bn">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS,</span>
<span id="cb1-69"><a href="#cb1-69"></a>             -<span class="dv">1</span>, <span class="dv">0</span>);</span>
<span id="cb1-70"><a href="#cb1-70"></a>  <span class="cf">if</span> (!mem)</span>
<span id="cb1-71"><a href="#cb1-71"></a>    err(<span class="dv">1</span>, <span class="st">&quot;allocating guest memory&quot;</span>);</span>
<span id="cb1-72"><a href="#cb1-72"></a>  memcpy(mem, code, <span class="kw">sizeof</span>(code));</span>
<span id="cb1-73"><a href="#cb1-73"></a></span>
<span id="cb1-74"><a href="#cb1-74"></a>  <span class="co">/* Map it to the second page frame (to avoid the real-mode IDT at 0). */</span></span>
<span id="cb1-75"><a href="#cb1-75"></a>  <span class="kw">struct</span> kvm_userspace_memory_region region = {</span>
<span id="cb1-76"><a href="#cb1-76"></a>      .slot = <span class="dv">0</span>,</span>
<span id="cb1-77"><a href="#cb1-77"></a>      .guest_phys_addr = <span class="bn">0x1000</span>,</span>
<span id="cb1-78"><a href="#cb1-78"></a>      .memory_size = <span class="bn">0x1000</span>,</span>
<span id="cb1-79"><a href="#cb1-79"></a>      .userspace_addr = (<span class="dt">uint64_t</span>)mem,</span>
<span id="cb1-80"><a href="#cb1-80"></a>  };</span>
<span id="cb1-81"><a href="#cb1-81"></a>  ret = ioctl(vmfd, KVM_SET_USER_MEMORY_REGION, &amp;region);</span>
<span id="cb1-82"><a href="#cb1-82"></a>  <span class="cf">if</span> (ret == -<span class="dv">1</span>)</span>
<span id="cb1-83"><a href="#cb1-83"></a>    err(<span class="dv">1</span>, <span class="st">&quot;KVM_SET_USER_MEMORY_REGION&quot;</span>);</span>
<span id="cb1-84"><a href="#cb1-84"></a></span>
<span id="cb1-85"><a href="#cb1-85"></a>  vcpufd = ioctl(vmfd, KVM_CREATE_VCPU, (<span class="dt">unsigned</span> <span class="dt">long</span>)<span class="dv">0</span>);</span>
<span id="cb1-86"><a href="#cb1-86"></a>  <span class="cf">if</span> (vcpufd == -<span class="dv">1</span>)</span>
<span id="cb1-87"><a href="#cb1-87"></a>    err(<span class="dv">1</span>, <span class="st">&quot;KVM_CREATE_VCPU&quot;</span>);</span>
<span id="cb1-88"><a href="#cb1-88"></a></span>
<span id="cb1-89"><a href="#cb1-89"></a>  <span class="co">/* Map the shared kvm_run structure and following data. */</span></span>
<span id="cb1-90"><a href="#cb1-90"></a>  ret = ioctl(kvm, KVM_GET_VCPU_MMAP_SIZE, NULL);</span>
<span id="cb1-91"><a href="#cb1-91"></a>  <span class="cf">if</span> (ret == -<span class="dv">1</span>)</span>
<span id="cb1-92"><a href="#cb1-92"></a>    err(<span class="dv">1</span>, <span class="st">&quot;KVM_GET_VCPU_MMAP_SIZE&quot;</span>);</span>
<span id="cb1-93"><a href="#cb1-93"></a>  mmap_size = ret;</span>
<span id="cb1-94"><a href="#cb1-94"></a>  <span class="cf">if</span> (mmap_size &lt; <span class="kw">sizeof</span>(*run))</span>
<span id="cb1-95"><a href="#cb1-95"></a>    errx(<span class="dv">1</span>, <span class="st">&quot;KVM_GET_VCPU_MMAP_SIZE unexpectedly small&quot;</span>);</span>
<span id="cb1-96"><a href="#cb1-96"></a>  run = mmap(NULL, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED, vcpufd, <span class="dv">0</span>);</span>
<span id="cb1-97"><a href="#cb1-97"></a>  <span class="cf">if</span> (!run)</span>
<span id="cb1-98"><a href="#cb1-98"></a>    err(<span class="dv">1</span>, <span class="st">&quot;mmap vcpu&quot;</span>);</span>
<span id="cb1-99"><a href="#cb1-99"></a></span>
<span id="cb1-100"><a href="#cb1-100"></a>  <span class="co">/* Initialize CS to point at 0, via a read-modify-write of sregs. */</span></span>
<span id="cb1-101"><a href="#cb1-101"></a>  ret = ioctl(vcpufd, KVM_GET_SREGS, &amp;sregs);</span>
<span id="cb1-102"><a href="#cb1-102"></a>  <span class="cf">if</span> (ret == -<span class="dv">1</span>)</span>
<span id="cb1-103"><a href="#cb1-103"></a>    err(<span class="dv">1</span>, <span class="st">&quot;KVM_GET_SREGS&quot;</span>);</span>
<span id="cb1-104"><a href="#cb1-104"></a>  sregs.cs.base = <span class="dv">0</span>;</span>
<span id="cb1-105"><a href="#cb1-105"></a>  sregs.cs.selector = <span class="dv">0</span>;</span>
<span id="cb1-106"><a href="#cb1-106"></a>  ret = ioctl(vcpufd, KVM_SET_SREGS, &amp;sregs);</span>
<span id="cb1-107"><a href="#cb1-107"></a>  <span class="cf">if</span> (ret == -<span class="dv">1</span>)</span>
<span id="cb1-108"><a href="#cb1-108"></a>    err(<span class="dv">1</span>, <span class="st">&quot;KVM_SET_SREGS&quot;</span>);</span>
<span id="cb1-109"><a href="#cb1-109"></a></span>
<span id="cb1-110"><a href="#cb1-110"></a>  <span class="co">/* Initialize registers: instruction pointer for our code, addends, and</span></span>
<span id="cb1-111"><a href="#cb1-111"></a><span class="co">   * initial flags required by x86 architecture. */</span></span>
<span id="cb1-112"><a href="#cb1-112"></a>  <span class="kw">struct</span> kvm_regs regs = {</span>
<span id="cb1-113"><a href="#cb1-113"></a>      .rip = <span class="bn">0x1000</span>,</span>
<span id="cb1-114"><a href="#cb1-114"></a>      .rax = <span class="dv">2</span>,</span>
<span id="cb1-115"><a href="#cb1-115"></a>      .rbx = <span class="dv">2</span>,</span>
<span id="cb1-116"><a href="#cb1-116"></a>      .rflags = <span class="bn">0x2</span>,</span>
<span id="cb1-117"><a href="#cb1-117"></a>  };</span>
<span id="cb1-118"><a href="#cb1-118"></a>  ret = ioctl(vcpufd, KVM_SET_REGS, &amp;regs);</span>
<span id="cb1-119"><a href="#cb1-119"></a>  <span class="cf">if</span> (ret == -<span class="dv">1</span>)</span>
<span id="cb1-120"><a href="#cb1-120"></a>    err(<span class="dv">1</span>, <span class="st">&quot;KVM_SET_REGS&quot;</span>);</span>
<span id="cb1-121"><a href="#cb1-121"></a></span>
<span id="cb1-122"><a href="#cb1-122"></a>  <span class="co">/* Repeatedly run code and handle VM exits. */</span></span>
<span id="cb1-123"><a href="#cb1-123"></a>  <span class="cf">while</span> (<span class="dv">1</span>) {</span>
<span id="cb1-124"><a href="#cb1-124"></a>    ret = ioctl(vcpufd, KVM_RUN, NULL);</span>
<span id="cb1-125"><a href="#cb1-125"></a>    <span class="cf">if</span> (ret == -<span class="dv">1</span>)</span>
<span id="cb1-126"><a href="#cb1-126"></a>      err(<span class="dv">1</span>, <span class="st">&quot;KVM_RUN&quot;</span>);</span>
<span id="cb1-127"><a href="#cb1-127"></a>    <span class="cf">switch</span> (run-&gt;exit_reason) {</span>
<span id="cb1-128"><a href="#cb1-128"></a>    <span class="cf">case</span> KVM_EXIT_HLT:</span>
<span id="cb1-129"><a href="#cb1-129"></a>      puts(<span class="st">&quot;KVM_EXIT_HLT&quot;</span>);</span>
<span id="cb1-130"><a href="#cb1-130"></a>      <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb1-131"><a href="#cb1-131"></a>    <span class="cf">case</span> KVM_EXIT_IO:</span>
<span id="cb1-132"><a href="#cb1-132"></a>      <span class="cf">if</span> (run-&gt;io.direction == KVM_EXIT_IO_OUT &amp;&amp; run-&gt;io.size == <span class="dv">1</span> &amp;&amp;</span>
<span id="cb1-133"><a href="#cb1-133"></a>          run-&gt;io.port == <span class="bn">0x3f8</span> &amp;&amp; run-&gt;io.count == <span class="dv">1</span>)</span>
<span id="cb1-134"><a href="#cb1-134"></a>        putchar(*(((<span class="dt">char</span> *)run) + run-&gt;io.data_offset));</span>
<span id="cb1-135"><a href="#cb1-135"></a>      <span class="cf">else</span></span>
<span id="cb1-136"><a href="#cb1-136"></a>        errx(<span class="dv">1</span>, <span class="st">&quot;unhandled KVM_EXIT_IO&quot;</span>);</span>
<span id="cb1-137"><a href="#cb1-137"></a>      <span class="cf">break</span>;</span>
<span id="cb1-138"><a href="#cb1-138"></a>    <span class="cf">case</span> KVM_EXIT_FAIL_ENTRY:</span>
<span id="cb1-139"><a href="#cb1-139"></a>      errx(<span class="dv">1</span>, <span class="st">&quot;KVM_EXIT_FAIL_ENTRY: hardware_entry_failure_reason = 0x%llx&quot;</span>,</span>
<span id="cb1-140"><a href="#cb1-140"></a>           (<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span>)run-&gt;fail_entry.hardware_entry_failure_reason);</span>
<span id="cb1-141"><a href="#cb1-141"></a>    <span class="cf">case</span> KVM_EXIT_INTERNAL_ERROR:</span>
<span id="cb1-142"><a href="#cb1-142"></a>      errx(<span class="dv">1</span>, <span class="st">&quot;KVM_EXIT_INTERNAL_ERROR: suberror = 0x%x&quot;</span>,</span>
<span id="cb1-143"><a href="#cb1-143"></a>           run-&gt;internal.suberror);</span>
<span id="cb1-144"><a href="#cb1-144"></a>    <span class="cf">default</span>:</span>
<span id="cb1-145"><a href="#cb1-145"></a>      errx(<span class="dv">1</span>, <span class="st">&quot;exit_reason = 0x%x&quot;</span>, run-&gt;exit_reason);</span>
<span id="cb1-146"><a href="#cb1-146"></a>    }</span>
<span id="cb1-147"><a href="#cb1-147"></a>  }</span>
<span id="cb1-148"><a href="#cb1-148"></a>}</span></code></pre></div>
<h1 id="qemu">Qemu</h1>
<p><img src="../pictures/io-emulation-in-kvm-qemu.png" /></p>
<p>source: <a href="https://doi.org/10.2200/S00754ED1V01Y201701CAC038">Hardware and Software Support for Virtualization</a></p>
<h1 id="next-step">Next step</h1>
<h2 id="other-virtualization-techniques">other virtualization techniques</h2>
<p><img src="../pictures/comparison-of-virtualization-techniques.png" /></p>
<p>source: <a href="https://www.vmware.com/content/dam/digitalmarketing/vmware/en/pdf/techpaper/VMware_paravirtualization.pdf">Understanding Full Virtualization, Paravirtualization, and Hardware Assist</a></p>
<h2 id="memory-virtualization">memory virtualization</h2>
<h2 id="interupt-virtualiazation">interupt virtualiazation</h2>
<h2 id="more-platforms">more platforms</h2>
<h2 id="virtualization-on-platforms-whose-isa-does-not-support-virtualisation">virtualization on platforms whose ISA does not support virtualisation</h2>
<h2 id="performance">performance</h2>
<h2 id="static-partition-virtualization">static partition virtualization</h2>
<h2 id="os-level-virtualization">OS-level virtualization</h2>
<h2 id="para-virtualization">para-virtualization</h2>
<h2 id="emulation">emulation</h2>


    </section>
  </article>
  
</body>
</html>
